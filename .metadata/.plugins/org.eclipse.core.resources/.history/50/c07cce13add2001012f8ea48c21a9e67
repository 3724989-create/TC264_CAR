
#include "Self_mtv90x.h"

#define row1 70
#define col1 188
#define WHITE_Pixie 255
#define BLACK_Pixie 0

int Left[70]={89 , 88 , 87 ,  86 ,  86 ,  85 ,  84 ,  83 ,  82 ,  81 ,  80 ,  79 ,  79 ,  78 ,  77 ,  76 ,  75 ,  74 ,  74 ,  73 ,  72 ,  71 ,  70 ,
        69 ,  68 ,  67 ,  66 ,  65 ,  64 ,  63 ,  62 ,  61 ,  60 ,  59 ,  58 ,  57 ,  56 ,  55 ,  54 ,  53 ,  53 ,  52 ,  51 ,  49 ,  48 ,  48 ,  47 ,
        46 ,  45 ,  44 ,  44 ,  43 ,  42 ,  41 ,  40 ,  40 ,  38 ,  37 ,  36 ,  35 ,  34 ,  33 ,  32 ,  31 ,  30 ,  29 ,  28 ,  27 ,
        26 ,  24
};
//int Right[70]={100 ,  101 ,  102 ,  103 ,  104 ,  105 ,  106 ,  107 ,  108 ,  109 ,  109 ,  110 ,  111 ,  112 ,  113 ,  114 ,  115 ,  115 ,  116 ,
//        117 ,  118 ,  119 ,  120 ,  121 ,  122 ,  123 ,  123 ,  124 ,  125 ,  126 ,  127 ,  128 ,  129 ,  129 ,  130 ,  131 ,  132 ,  133 ,  134 ,
//        135 ,  135 ,  136 ,  137 ,  138 ,  139 ,  140 ,  141 ,  142 ,  143 ,  144 ,  144 ,  145 ,  146 ,  147 ,  148 ,  149 ,  150 ,  151 ,  152 ,
//        153 ,  154 ,  155 ,  156 ,  157 ,  158 ,  158 ,  159 ,  160 ,  161 ,  163
//};
int Right[70]={103 ,  104 ,  105 ,  106 ,  106 ,  107 ,  108 ,  109 ,  110 ,  110 ,  111 ,  112 ,  113 ,  114 ,  115 ,  115 ,  116 ,  117 ,  118 ,
        119 ,  120 ,  121 ,  122 ,  122 ,  123 ,  124 ,  125 ,  126 ,  127 ,  128 ,  129 ,  130 ,  131 ,  131 ,  132 ,  133 ,  134 ,  135 ,  136 ,
        137 ,  138 ,  139 ,  140 ,  141 ,  142 ,  142 ,  143 ,  144 ,  145 ,  146 ,  147 ,  148 ,  149 ,  150 ,  151 ,  152 ,  152 ,  153 ,  154 ,
        155 ,  156 ,  157 ,  157 ,  158 ,  159 ,  160 ,  161 ,  162 ,  163 ,  164
};

uint8_t Process_Array[row1][col1];

void self_mtv90x_init(void)
{
    ips114_init();
    ips114_show_string(0, 0, "mt9v03x init.");
    while(1)
    {
        if(mt9v03x_init())
            ips114_show_string(0, 16, "mt9v03x reinit.");
        else
            break;
        system_delay_ms(500);                                     // 短延时快速闪灯表示异常
    }

}

uint8_t my_adapt_threshold(uint8_t *image,uint16_t col,uint16_t row)
{
    #define GrayScale 256
    uint16_t width = col;
    uint16_t height = row;
    int pixelCount[GrayScale];
    float pixelPRo[GrayScale];
    int i, j, pixelSum = (width) * (height - 60) / 9;
    uint8_t threshold = 0;
    uint8_t* data = image;
    uint32_t gray_sum = 0;
    float w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = 0;

    for (i = 0; i < GrayScale; i++)
    {
        pixelCount[i] = 0;
        pixelPRo[i] = 0;
    }
    //统计灰度级中每个像素在整幅图像中的个数
    for ( i = 10; i < height - 50; i += 3)
    {
        for (j = 0; j < width; j += 3)
        {
            pixelCount[(int)data[i * width + j]]++; //将当前点的像素值作为计数数组值下标
            gray_sum += (int)data[i * width + j];    //灰度值总和
        }
    }

    //计算每个像素值的点在正负图像中的比例

    for ( i = 0; i < GrayScale; i++)
    {
        pixelPRo[i] = (float)pixelCount[i] / pixelSum;
    }
    
    w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = 0;
    for(j = 0; j < GrayScale; j++)    //当前尝试阈值
    {
        w0 += pixelPRo[j];      //背景部分每个灰度值的像素点所占比例之和，即背景部分的比例
        u0tmp += j * pixelPRo[j];   //背景部分，每个灰度值点的比例

        w1 = 1 - w0;
        u1tmp = gray_sum / pixelSum - u0tmp;

        u0 = u0tmp / w0;    //背景平均灰度
        u1 = u1tmp / w1;    //前景平均灰度
        u = u0tmp + u1tmp;
        deltaTmp = w0 * pow((u0 - u), 2) + w1 * pow((u1 - u), 2); //计算最大类间方差
        if(deltaTmp > deltaMax)
        {
            deltaMax = deltaTmp;
            threshold = (uint8_t)j;
        }
        if(deltaTmp < deltaMax)
        {
            break;
        }
    }
    return threshold;
}

uint8_t OTSU_Th;
uint8_t Image_Value = 80;
void Binarization(void)
{
    uint8_t threshold = 0;
    threshold = Limit_ab_uint8_t(my_adapt_threshold(mt9v03x_image[0], MT9V03X_W, MT9V03X_H), Image_Value, 250);
    OTSU_Th = threshold;
    float zenyi = 0, zenyj = 0;

    for(int Y = 10; Y < 10 + row1; Y++)
    {
        if(Y < 60)
        {
            zenyi = 4;
        }

        for(int X = 0; X < col1; X++)
        {
            zenyj = (float)abs(X - 93) / 92.0 * 12.0;
            Process_Array[Y - 10][X] = (mt9v03x_image[Y][X] > OTSU_Th + zenyi - zenyj) ? 0xff : 0x00; //1白 0黑
            //使得边缘区域的像素更容易满足 mt9v03x_image[Y][X] > Threshold 的条件，从而更容易被判断为白色（背景）
        }
    }

}

#define left   0
#define center 1
#define right  2
#define up     3

#define MisEdge  0
#define Normal   1
#define UnNormal 2

#define Limit_Range  5

#define Up_LongLine_Left    0
#define Up_LongLine_Centre  1
#define Up_LongLine_Right   2


extern float up_long_sum,up_long_num_sum;
uint8_t Min,Up_Long_Line,Min_Line;
uint8_t Underwind=28,Upwind=22;
uint8_t Realwind=40;//真实打脚行
uint8_t Cut_Line=20;//截断行
uint8_t LeftLine[row1]={0},RightLine[row1]={0};
uint8_t RightFindFlag[row1]={0},LeftFindFlag[row1]={0};
uint8_t fiv_width[row1]={0};//图像每一行的宽度
uint8_t MidLine[row1]={0};//图像每一行的宽度
uint8_t Up[188];

uint8_t Up_Long_Line=94;
uint8_t Up_LongLine_Tactics;

Element_Type Element_Circle_LeftSide  ={Circle_LeftSide,UnLock,0};  //左圆环
Element_Type Element_Circle_RightSide ={Circle_RightSide,UnLock,0}; //右圆环
Element_Type Element_Centre_Cross     ={Centre_Cross,UnLock,0};     //中十字
Element_Type Element_Left_Cross       ={Left_Cross,UnLock,0};       //左入十字
Element_Type Element_Right_Cross      ={Right_Cross,UnLock,0};      //右入十字
Element_Type Element_Right_Block      ={ Right_Block,UnLock,0};     //右路障
Element_Type Element_Left_Block       ={ Left_Block,UnLock,0 };     //路障
Element_Type Element_Garage           ={Garage,UnLock,0};           //车库
Element_Type Element_Garage_Out       ={Garage_Out,UnLock,0};       //出库
Element_Type Element_Ramp             ={Ramp,UnLock,0};             //坡道

//-------------------------------------------------------------------------------------------------------------------
//  @brief      检查锁
////
//  @return     1为无锁，0为有锁 十字地位极低可以被打断
//-------------------------------------------------------------------------------------------------------------------
uint8_t Check_Lock(void)
{
  uint8_t Lock=1;
  if(Lock==1)
  {
      if(Element_Circle_LeftSide.Lock==Lock) {Lock=0;}
  }

  if(Lock==1)
  {
      if(Element_Circle_RightSide.Lock==Lock) {Lock=0;}
  }

  if(Lock==1)
  {
      if(Element_Left_Cross.Lock==Lock  && Element_Left_Cross.State!=1) {Lock=0;}//！！！！
  }

  if(Lock==1)
  {
      if(Element_Right_Cross.Lock==Lock && Element_Right_Cross.State!=1) {Lock=0;}//！！！！
  }


  if(Lock==1)
  {
      if(Element_Garage.Lock==Lock) {Lock=0;}
  }

  if(Lock==1)
  {
      if(Element_Garage_Out.Lock==Lock) {Lock=0;}
  }

  if(Lock==1)
  {
      if(Element_Right_Block.Lock==Lock) {Lock=0;}
  }

  if(Lock==1)
  {
      if(Element_Left_Block.Lock==Lock) {Lock=0;}
  }
  if(Lock==1)
  {
      if(Element_Ramp.Lock==Lock) {Lock=0;}
  }

  return Lock;
}

void GetJumpPointFromDet(uint8_t type,uint8_t Limit,uint8_t Y)
{
    uint8_t Limit_R=Limit_ab_uint8_t((int)LeftLine[Y+1]+Limit,2,185);   //限制左右范围,从右边开始找左边线
    uint8_t Limit_L = Limit_ab_uint8_t((int)RightLine[Y + 1] - Limit, 2, 185);//限制左右范围，从左边开始找右边线

    if(type==left)
    {
        for(uint8_t X=Limit_R;X>=2;X--)
        {
            if (Process_Array[Y][X] == WHITE_Pixie && Process_Array[Y][X - 1] == BLACK_Pixie && Process_Array[Y][X - 2] == BLACK_Pixie)//滤波
            {
                LeftLine[Y] = X;
                LeftFindFlag[Y] = Normal;
                break;
            }
            else if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X - 1] == BLACK_Pixie && Process_Array[Y][LeftLine[Y + 1]] == BLACK_Pixie)
            {
                LeftLine[Y] = Limit_R;//划为最大值  后面会找出该点的右边值
                LeftFindFlag[Y] = UnNormal;//判为不正常突变
                break;
            }
            if(X==2)
            {
                if(Process_Array[Y][LeftLine[Y+1]]==WHITE_Pixie)//未找到边线，且找寻范围中间时白点
                {
                    LeftLine[Y]=0;              //继承上一点的X坐标
                    LeftFindFlag[Y]=MisEdge;    //判断为丢线
                }
            }
        }
    }
    else if(type==right)
    {
        for(uint8_t X = Limit_L; X <= 185; X++)
        {
            if (Process_Array[Y][X] == WHITE_Pixie && Process_Array[Y][X + 1] == BLACK_Pixie && Process_Array[Y][X + 2] == BLACK_Pixie)//滤波
            {
                RightLine[Y] = X;
                RightFindFlag[Y] = Normal;
                break;
            }
            else if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X + 1] == BLACK_Pixie && Process_Array[Y][LeftLine[Y + 1]] == BLACK_Pixie)
            {
                RightLine[Y] = Limit_L;//划为最大值  后面会找出该点的右边值
                RightFindFlag[Y] = UnNormal;//判为不正常突变
                break;
            }
            if(X==2)
            {
                if(Process_Array[Y][LeftLine[Y+1]]==WHITE_Pixie)//未找到边线，且找寻范围中间时白点.判断条件保证其在赛道内
                {
                    RightLine[Y]=185;              //继承上一点的X坐标
                    RightFindFlag[Y]=MisEdge;    //判断为丢线
                }
            }
        }
    }
}

void Image_Scanning(void)
{
    int16 X,Y;
    uint8_t Limit_L=0,Limit_R=186;    //上扫线限制
    static uint8_t Old_Center=94;     //中线追踪

    //刷新打脚行，截断行
    Realwind=Underwind;
    Cut_Line=10;
    if(Element_Garage_Out.Lock==Lock)
    {
        RightLine[69]=(uint8_t)Right[67];
        LeftLine[69]=(uint8_t)Left[67];
        RightFindFlag[69]=1;
        LeftFindFlag[69]=1;
    }
    else
    {
        for(Y=69;Y>68;Y--)
        {
            RightLine[Y]=186;
            RightFindFlag[Y]=0;
            for (X=Old_Center;X<col1-2;X++)
            {
                if(Process_Array[Y][X]==BLACK_Pixie&&Process_Array[Y][X+1]==BLACK_Pixie)
                {
                    RightLine[Y]=(uint8_t)X;
                    RightFindFlag[Y]=1;
                    break;
                }   
            }
            LeftLine[Y]=0;
            LeftFindFlag[Y]=0;
            for (X=Old_Center;X<col1-2;X++)
            {
                if(Process_Array[Y][X]==BLACK_Pixie&&Process_Array[Y][X-1]==BLACK_Pixie)
                {
                    LeftLine[Y]=(uint8_t)X;
                    LeftFindFlag[Y]=1;
                    break;
                }   
            }
            //实时赛宽
            fiv_width[Y]=(uint8_t)Limit_ab_int((int)RightLine[Y]-(int)LeftLine[Y],0,186);
            //中线策略
            MidLine[Y] = (uint8_t)(((int)LeftLine[Y] + (int)RightLine[Y]) / 2);
            Old_Center=(uint8_t)MidLine[Y];
        }

    }
    Min=69;
    Limit_L=LeftLine[69],Limit_R=RightLine[69];
    for(X=0;X<=Limit_L;X++)
    {
        Up[X]=69;
    }
    for(X=col1-1;X>=Limit_R;X--)
    {
        Up[X]=69;
    }
    up_long_sum=0.01;
    up_long_num_sum=0.01;
    if(Check_Lock()==1||Element_Garage_Out.Lock==Lock)  //无元素时跑线
    {
        for(X=Limit_L+1;X<Limit_R-1;X++)
        {
            Up[X] = 1;
            for (Y = row1 - 1; Y > 1; Y--)
            {
                if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y - 1][X] == BLACK_Pixie)
                {
                    Up[X] = (uint8_t)Limit_ab_int((int)Y, 1, 68);
                    if (Up[X] < Min)
                    {
                        Min = Up[X];//找出最高行
                        Min_Line =(uint8_t) X;
                    }
                    break;
                }
            }
            if(X>70 && X<118)
            {
                up_long_sum+=(float)Up[X];
                up_long_num_sum+=1.0;
            }
        }
        for(Y=68;Y>Min;Y--) //根据打脚行扫线
        {
            GetJumpPointFromDet(left,Limit_Range,(uint8_t)Y);
            GetJumpPointFromDet(Right,Limit_Range,(uint8_t)Y);
            if(LeftLine[Y]==UnNormal)
            {
                for(X=LeftLine[Y]+1;X<Limit_ab_uint8_t(RightLine[Y],2,185);X++)   //从左到右扫描
                {
                    if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X + 1] == WHITE_Pixie && Process_Array[Y][X + 2] == WHITE_Pixie) 
                    {
                        LeftLine[Y] = X + 1;
                        LeftFindFlag[Y] = Normal;
                        break;
                    }
                    else if (Process_Array[Y][X] == WHITE_Pixie)
                    {
                        LeftLine[Y] = (uint8_t)X;
                        LeftFindFlag[Y] = Normal;
                        break;
                    }
                }
            }
            else if(RightLine[Y]==UnNormal)
            {
                for(X=RightLine[Y]-1;X>Limit_ab_uint8_t(LeftLine[Y],2,185);X--)   //从左到右扫描
                {
                    if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X - 1] == WHITE_Pixie && Process_Array[Y][X - 2] == WHITE_Pixie) 
                    {
                        LeftLine[Y] = (uint8_t)X - 1;
                        LeftFindFlag[Y] = Normal;
                        break;
                    }
                    else if (Process_Array[Y][X] == WHITE_Pixie)
                    {
                        RightLine[Y] = (uint8_t)X;
                        RightFindFlag[Y] = Normal;
                        break;
                    }
                }
            }
            fiv_width[Y]=RightLine[Y]-LeftLine[Y];
            MidLine[Y]=(uint8_t)(((int)LeftLine[Y]-(int)RightLine[Y])/2);
        }
        Old_Center=(uint8_t)MidLine[67];
        for ( Y=Min; Y>=0; Y--) //刷新并清理顶端扫描数据
        {
            LeftLine[Y]=0;
            LeftFindFlag[Y]=MisEdge;
            RightLine[Y]=186;
            RightFindFlag[Y]=MisEdge;
            fiv_width[Y]=0;
        }
        
    }
    else//有元素时自锁避免元素干扰扫线
    {
        uint8_t Mid=Limit_ab_uint8_t((RightLine[69]+LeftLine[69])/2,0,186);
        Min_Line=94;
        if(Up_LongLine_Tactics==Up_LongLine_Left)
        {
            for(X=RightLine[69];X>LeftLine[69];X--) //向上找，从右到左
            {
                Up[X]=1;//初始化所有的起始点
                for(Y=row1-1;Y>1;Y--)
                {
                    if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y - 1][X] == BLACK_Pixie)   //避免一直为1
                    {
                        Up[X] = Limit_ab_uint8((uint8_t)Y, 1, 68);
                        break;
                    }
                }
                //赛道引导线会尽量局左
                /*if (X < RightLine[69] - (RightLine[69] - LeftLine[69]) / 3 && X >LeftLine[69])*/
                if(X<Mid&&X>LeftLine[69])
                {
                    //绝对高||合理误差内偏左
                    if ((X < Mid && Up[X] <= Min) || (abs((int)Up[X] - (int)Min) < 2 && X < Min_Line))
                    {
                        //二次判断
                        if(Up[X]<=Min)
                        {
                            Min=Up[X];
                        }
                        Min_Line = Limit_ab_uint8((uint8_t)X, 0, 186);
                    }

                }
                if(X>70 && X<118)
                {
                up_long_sum+=(float)Up[X];
                up_long_num_sum+=1.0;
                }
            }
           Up_Long_Line = Limit_ab_uint8(Min_Line, 3, 184);//确定赛道引导线，用于转向
           Min = Up[Up_Long_Line];//改变顶
        }

        else if(Up_LongLine_Tactics==Up_LongLine_Right)
        {
            for(X=LeftLine[69];X<RightLine[69];X++) //向上找，从左到右
            {
                Up[X]=1;//初始化所有的起始点
                for(Y=row1-1;Y>1;Y--)
                {
                    if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y - 1][X] == BLACK_Pixie)   //避免一直为1
                    {
                        Up[X] = Limit_ab_uint8((uint8_t)Y, 1, 68);
                        break;
                    }
                }
                //赛道引导线会尽量局右
                /*if (X < RightLine[69] - (RightLine[69] - LeftLine[69]) / 3 && X >LeftLine[69])*/
                if(X>Mid&&X<RightLine[69])
                {
                    //绝对高||合理误差内偏左
                    if ((X >Mid && Up[X] <= Min) || (abs((int)Up[X] - (int)Min) < 2 && X > Min_Line))
                    {
                        //二次判断
                        if(Up[X]<=Min)
                        {
                            Min=Up[X];
                        }
                        Min_Line = Limit_ab_uint8((uint8_t)X, 0, 186);
                    }

                }
                if(X>70 && X<118)   //对中心区域进行行高统计
                {
                up_long_sum+=(float)Up[X];
                up_long_num_sum+=1.0;
                }
            }
           Up_Long_Line = Limit_ab_uint8(Min_Line, 3, 184);//确定赛道引导线，用于转向
           Min = Up[Up_Long_Line];//改变顶
        }
        else    //其余策略为中
        {
            for(X=RightLine[69];X>LeftLine[69];X--)
            {
                Up[X]=1;
                for (Y = row1 - 2; Y > 1; Y--)
                {
                    if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y - 1][X] == BLACK_Pixie)
                    {
                        Up[X] = Limit_ab_uint8((uint8_t)Y, 1, 68);
                        break;
                    }
                } 
                if(X<RightLine[69]-(RightLine[69]-LeftLine[69])/3&&X>LeftLine[69]+(RightLine[69]-LeftLine[69])/3)   //控制在中间的1/3区域以内
                {
                    if(Up[X]<Min||(Up[X]==Min&&abd(94-(int)X)<abs(94-(int)Min_Line)))   //如果更高或者更靠近中点
                    {
                        Min_Line=Up[X];
                        Min_Line=Limit_ab_uint8((uint8_t)X,0,186);
                    }
                }
                if(X>70 && X<118)
                {
                    up_long_sum+=(float)Up[X];
                    up_long_num_sum+=1.0;

                }
            }
            Up_Long_Line = Limit_ab_uint8(Min_Line, 3, 184);//确定赛道引导线
            Min = Up[Up_Long_Line];//改变顶
        }
        for(Y=row1-1;Y>Up[Up_Long_Line];Y--)
        {
            RightLine[Y] = 186;
            RightFindFlag[Y] = 0;
            for (X = Up_Long_Line; X < col1 - 2; X++)
            {
                //找到边界  右
                if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X + 1] == BLACK_Pixie)
                {
                    RightLine[Y] = Limit_ab_uint8((uint8)X, 0, 186);
                    RightFindFlag[Y] = 1;
                    break;
                }

            }
            LeftLine[Y] = 0;
            LeftFindFlag[Y] = 0;
            for (X = Up_Long_Line; X > 1; X--)
            {
                if (Process_Array[Y][X] == BLACK_Pixie && Process_Array[Y][X - 1] == BLACK_Pixie)
                {
                    LeftLine[Y] = Limit_ab_uint8((uint8)X, 0, 186);
                    LeftFindFlag[Y] = 1;
                    break;
                }
            }
                        //实时赛宽
            fiv_width[Y] = Limit_ab_uint8(RightLine[Y] - LeftLine[Y], 0, 186);
            //中线策略
            MidLine[Y] = (uint8_t)(((int)LeftLine[Y] + (int)RightLine[Y]) / 2);
        }
        Old_Center=(uint8_t)Limit_ab_int(MidLine[67],2,184);
     }
     up_long_sum/=up_long_num_sum;      //平均行高
}

//修复丢线情况
void Repair_Virsual(void)
{
    for (uint8_t Y = 69; Y > Min; Y--)
    {
        if (LeftFindFlag[Y] == 0 && RightFindFlag[Y]==1)
        {
            int error = (int)RightLine[Y] - (int)Right[Y];
            MidLine[Y] = Limit_ab_int((int)93+error*2,0,186);
        }
        else if(LeftFindFlag[Y] == 1 && RightFindFlag[Y] == 0)
        {
            int error = (int)LeftLine[Y] - (int)Left[Y];
            MidLine[Y] = Limit_ab_int((int)93 + error*2, 0, 186);
            //printf("error:%d\n", error);
        }
        else
        {
            int error = (int)LeftLine[Y] - (int)Left[Y] + (int)RightLine[Y] - (int)Right[Y];
            MidLine[Y] = Limit_ab_int((int)93 + error , 0, 186);
           // MidLine[Y] = ((int)RightLine[Y] + (int)LeftLine[Y]) / 2;
        }
    }
}

void self_mtv90x_process(void)
{
    if(mt9v03x_finish_flag)
    {
        //ips114_displayimage03x((const uint8_t *)mt9v03x_image, MT9V03X_W, MT9V03X_H);        // 显示原始图像
        Binarization();
        //ips114_displayimage03x((const uint8_t *)Process_Array, MT9V03X_W, MT9V03X_H);
        ips114_show_gray_image(0, 0, (const uint8_t *)Process_Array, col1, row1, col1, row1, 0);       // 显示灰度图像
        mt9v03x_finish_flag = 0;
    }
}
 